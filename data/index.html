<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>LED Matrix</title>
    <link rel="stylesheet" href="/style.css" />
  </head>
  <body>
    <header>
      <h1>LED Matrix</h1>
      <div id="status">Connecting…</div>
      <div class="spacer"></div>
      <div class="toolbar">
        <button id="refresh">Refresh</button>
        <button id="clear" title="Turn off all pixels">Clear</button>
        <button id="fill" title="Turn on all pixels">Fill</button>
        <label style="font-size:12px;display:flex;align-items:center;gap:6px;">
          <input id="auto" type="checkbox" checked /> Auto-refresh
        </label>
        <label style="font-size:12px;display:flex;align-items:center;gap:8px;">
          <span style="opacity:.8;">Brightness</span>
          <input id="brightness" type="range" min="0" max="15" value="3" />
          <span id="bval">3</span>
        </label>
      </div>
    </header>
    <main>
      <aside id="palette">
        <h2>Visualizations</h2>
        <div id="visualizations"></div>
      </aside>
      <div id="grid"></div>
      <aside id="viz-controls" hidden>
        <h2>Snow</h2>
        <div id="snow-controls" class="controls">
          <div class="control-group">
            <label for="snow-gravity">Gravity (ms)</label>
            <input type="number" id="snow-gravity" data-snow-param="gravity" min="0" max="2000" step="10" />
            <small>Time between downward steps. Set 0 to freeze snow in place.</small>
          </div>
          <div class="control-group">
            <label for="snow-snowRate">Snow Rate (ms)</label>
            <input type="number" id="snow-snowRate" data-snow-param="snowRate" min="0" max="5000" step="50" />
            <small>Lower values create flakes more frequently. 0 disables new snow.</small>
          </div>
          <div class="control-group">
            <label for="snow-meltRate">Melt Rate (ms)</label>
            <input type="number" id="snow-meltRate" data-snow-param="meltRate" min="0" max="10000" step="100" />
            <small>Lower values melt faster. 0 disables melting.</small>
          </div>
          <div class="control-group">
            <label for="snow-wind">Wind (%)</label>
            <input type="range" id="snow-wind" data-snow-param="wind" min="0" max="100" step="1" />
            <div class="value"><span id="snow-wind-value">0%</span></div>
          </div>
        </div>
      </aside>
    </main>
    <script>
      let cols = 0, rows = 0;
      let fb = [];
      let timer = null;
      let isDrawing = false;
      let drawOp = 'paint'; // 'paint' | 'erase'
      let hasMoved = false;
      let startX = 0, startY = 0;
      let drawn;
      let suppressNextClick = false; // used to suppress shift-click default click
      let visualizations = [];
      let currentVisualizationId = '';
      let switchingVisualization = false;
      let snowConfig = null;
      let snowUpdateTimer = null;

      const $ = (s) => document.querySelector(s);
      const grid = $("#grid");
      const statusEl = $("#status");
      const visualizationList = $("#visualizations");
      const vizControls = $("#viz-controls");
      const snowControls = $("#snow-controls");
      const snowGravityInput = $("#snow-gravity");
      const snowRateInput = $("#snow-snowRate");
      const snowMeltRateInput = $("#snow-meltRate");
      const snowWindInput = $("#snow-wind");
      const snowWindValue = $("#snow-wind-value");

      function setStatus(text) { statusEl.textContent = text; }

      function renderVisualizationPalette() {
        if (!visualizationList) return;
        visualizationList.innerHTML = '';
        visualizations.forEach((viz) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'palette-button';
          button.dataset.id = viz.id;
          button.textContent = viz.label || viz.id;
          if (viz.id === currentVisualizationId) {
            button.classList.add('selected');
          }
          if (switchingVisualization) {
            button.disabled = true;
            if (viz.id === currentVisualizationId) {
              button.disabled = false;
            }
          }
          button.addEventListener('click', () => selectVisualization(viz.id));
          visualizationList.appendChild(button);
        });
        ensureVisualizationControls();
      }

      async function loadVisualizations() {
        if (!visualizationList) return;
        try {
          const r = await fetch('/visualizations', { cache: 'no-store' });
          if (!r.ok) throw new Error('failed');
          const data = await r.json();
          visualizations = Array.isArray(data.visualizations) ? data.visualizations : [];
          currentVisualizationId = data.current || '';
          renderVisualizationPalette();
          ensureVisualizationControls();
        } catch (e) {
          // ignore failures; palette will remain unchanged
        }
      }

      async function selectVisualization(id) {
        if (!id || id === currentVisualizationId || switchingVisualization) return;
        if (!visualizationList) return;
        switchingVisualization = true;
        renderVisualizationPalette();
        try {
          setStatus(`Loading ${id}…`);
          const r = await fetch(`/visualizations?id=${encodeURIComponent(id)}`, { method: 'POST' });
          if (!r.ok) throw new Error('failed');
          const data = await r.json();
          currentVisualizationId = data.current || id;
          await refresh();
          await ensureVisualizationControls();
        } catch (e) {
          setStatus('Failed to change visualization');
          await loadVisualizations();
        } finally {
          switchingVisualization = false;
          renderVisualizationPalette();
        }
      }

      async function fetchSnowConfig() {
        try {
          const r = await fetch('/visualizations/snow/config', { cache: 'no-store' });
          if (!r.ok) throw new Error('failed');
          snowConfig = await r.json();
          updateSnowControlsUI();
        } catch (e) {
          snowConfig = null;
        }
      }

      function updateSnowControlsUI() {
        if (!snowControls || !snowConfig) return;
        if (snowGravityInput && typeof snowConfig.gravity === 'number') snowGravityInput.value = snowConfig.gravity;
        if (snowRateInput && typeof snowConfig.snowRate === 'number') snowRateInput.value = snowConfig.snowRate;
        if (snowMeltRateInput && typeof snowConfig.meltRate === 'number') snowMeltRateInput.value = snowConfig.meltRate;
        if (snowWindInput && typeof snowConfig.wind === 'number') {
          snowWindInput.value = snowConfig.wind;
          if (snowWindValue) snowWindValue.textContent = `${snowConfig.wind}%`;
        }
      }

      async function ensureVisualizationControls() {
        if (!vizControls) return;
        if (currentVisualizationId === 'snow') {
          vizControls.hidden = false;
          if (!snowConfig) {
            await fetchSnowConfig();
          } else {
            updateSnowControlsUI();
          }
        } else {
          vizControls.hidden = true;
          snowConfig = null;
        }
      }

      function scheduleSnowUpdate(name, value) {
        if (currentVisualizationId !== 'snow') return;
        const num = Number(value);
        if (Number.isNaN(num)) return;
        if (!snowConfig) snowConfig = {};
        let numeric = Math.max(0, Math.round(num));
        if (name === 'wind') {
          numeric = Math.max(0, Math.min(100, numeric));
        }
        snowConfig[name] = numeric;
        updateSnowControlsUI();
        if (snowUpdateTimer) {
          clearTimeout(snowUpdateTimer);
        }
        snowUpdateTimer = setTimeout(async () => {
          if (!snowConfig) return;
          try {
            const params = new URLSearchParams();
            ['gravity', 'snowRate', 'meltRate', 'wind'].forEach((key) => {
              if (snowConfig[key] !== undefined && snowConfig[key] !== null) {
                params.set(key, snowConfig[key]);
              }
            });
            const r = await fetch(`/visualizations/snow/config?${params.toString()}`, { method: 'PUT' });
            if (!r.ok) throw new Error('failed');
            snowConfig = await r.json();
            updateSnowControlsUI();
          } catch (e) {
            await fetchSnowConfig();
          }
        }, 200);
      }

      if (snowControls) {
        snowControls.addEventListener('change', (e) => {
          if (!e.target || !e.target.dataset) return;
          const param = e.target.dataset.snowParam;
          if (!param) return;
          scheduleSnowUpdate(param, e.target.value);
        });
      }

      if (snowWindInput && snowWindValue) {
        snowWindInput.addEventListener('input', (e) => {
          snowWindValue.textContent = `${e.target.value}%`;
        });
      }

      async function getDisplay() {
        const r = await fetch('/display', { cache: 'no-store' });
        if (!r.ok) throw new Error('Failed to fetch display');
        return r.json();
      }

      function cellOn(x, y) {
        return ((fb[y] >>> x) & 1) === 1;
      }

      function setCell(x, y, on) {
        const mask = (1 << x);
        if (on) fb[y] |= mask; else fb[y] &= ~mask;
      }

      async function writePixel(x, y, on) {
        setCell(x, y, on);
        renderCells();
        try {
          const url = `/display?x=${x}&y=${y}&on=${on ? 1 : 0}`;
          const r = await fetch(url, { method: 'PUT' });
          if (!r.ok) throw new Error('PUT failed');
        } catch (e) {
          await refresh();
        }
      }

      async function togglePixel(x, y) {
        const on = !cellOn(x, y);
        await writePixel(x, y, on);
      }

      function renderSkeleton() {
        grid.style.gridTemplateColumns = `repeat(${cols}, var(--cell))`;
        grid.innerHTML = '';
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            const d = document.createElement('div');
            d.className = 'cell';
            d.dataset.x = x;
            d.dataset.y = y;
            d.addEventListener('click', (e) => {
              if (suppressNextClick) { suppressNextClick = false; return; }
              togglePixel(x, y);
            });
            d.addEventListener('pointerdown', (e) => {
              isDrawing = true; hasMoved = false; startX = x; startY = y; drawn = new Set();
              drawOp = e.shiftKey ? 'erase' : 'paint';
              // For shift-click without movement, we'll erase on pointerup and suppress the click
              if (e.shiftKey) suppressNextClick = true;
            });
            d.addEventListener('pointerenter', async (e) => {
              if (!isDrawing) return;
              hasMoved = true;
              const key = y * cols + x;
              if (drawn.has(key)) return;
              drawn.add(key);
              await writePixel(x, y, drawOp === 'paint');
            });
            grid.appendChild(d);
          }
        }
      }

      function renderCells() {
        // Update classes without rebuilding DOM
        const children = grid.children;
        let i = 0;
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++, i++) {
            const on = cellOn(x, y);
            const el = children[i];
            if (!el) continue;
            if (on) el.classList.add('on'); else el.classList.remove('on');
          }
        }
      }

      async function refresh() {
        try {
          setStatus('Updating…');
          const data = await getDisplay();
          let rebuild = false;
          if (data.columns !== cols || data.rows !== rows) {
            cols = data.columns; rows = data.rows; rebuild = true;
          }
          fb = data.framebuffer || [];
          if (rebuild || grid.childElementCount !== cols * rows) renderSkeleton();
          renderCells();
          setStatus(`${cols} × ${rows}`);
        } catch (e) {
          setStatus('Disconnected');
        }
      }

      function startAutoRefresh() {
        stopAutoRefresh();
        timer = setInterval(refresh, 1000);
      }
      function stopAutoRefresh() { if (timer) { clearInterval(timer); timer = null; } }

      $('#refresh').addEventListener('click', refresh);
      function endDraw(e) {
        if (!isDrawing) return;
        const wasShift = (e && e.shiftKey) || (drawOp === 'erase');
        if (!hasMoved) {
          if (wasShift) {
            // Shift-click erase
            suppressNextClick = true;
            writePixel(startX, startY, false);
          } else {
            // Plain click toggles (handled by click handler)
          }
        }
        isDrawing = false;
        hasMoved = false;
        drawn = null;
      }
      window.addEventListener('pointerup', endDraw);
      window.addEventListener('pointercancel', endDraw);
      async function clearAll() {
        try {
          setStatus('Clearing…');
          const r = await fetch('/display', { method: 'DELETE' });
          if (!r.ok) throw new Error('DELETE failed');
          fb = Array.from({ length: rows }, () => 0);
          renderCells();
          setStatus(`${cols} × ${rows}`);
        } catch (e) {
          await refresh();
        }
      }
      $('#clear').addEventListener('click', clearAll);
      // Fill all pixels ON
      async function fillAll() {
        try {
          setStatus('Filling…');
          const r = await fetch('/display/fill?on=1', { method: 'POST' });
          if (!r.ok) throw new Error('POST failed');
          fb = Array.from({ length: rows }, () => (cols >= 32 ? 0xFFFFFFFF : ((1 << cols) - 1)));
          renderCells();
          setStatus(`${cols} × ${rows}`);
        } catch (e) {
          await refresh();
        }
      }
      $('#fill').addEventListener('click', fillAll);
      $('#auto').addEventListener('change', (e) => {
        if (e.target.checked) startAutoRefresh(); else stopAutoRefresh();
      });
      // Brightness control
      async function fetchBrightness() {
        try {
          const r = await fetch('/brightness', { cache: 'no-store' });
          if (!r.ok) return;
          const j = await r.json();
          const v = Math.max(0, Math.min(15, j.brightness|0));
          const slider = document.getElementById('brightness');
          const bval = document.getElementById('bval');
          slider.value = v; bval.textContent = v;
        } catch {}
      }
      let bTimer = null;
      function scheduleSetBrightness(v) {
        const bval = document.getElementById('bval');
        bval.textContent = v;
        if (bTimer) clearTimeout(bTimer);
        bTimer = setTimeout(async () => {
          try {
            await fetch(`/brightness?value=${v}`, { method: 'PUT' });
          } catch {}
        }, 150);
      }
      document.addEventListener('input', (e) => {
        if (e.target && e.target.id === 'brightness') {
          scheduleSetBrightness(e.target.value);
        }
      });

      loadVisualizations();
      refresh();
      fetchBrightness();
      startAutoRefresh();
    </script>
  </body>
  </html>
